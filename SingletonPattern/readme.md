#### 单例模式


* 定义：
    1. 当某个类有且仅有一个实例对象的情况下，可以使用单例模式。
-----
* 应用情景？
    1. 生活场景：用于确保某一事物的唯一性。如一个父亲参加两个孩子的家长会，两个孩子签到时，必须是同一个人
    2. 应用场景： 

-------
*  处理逻辑（解决方案）

1. 饿汉式单例
![eagersingleton.gif](eagersingleton.gif)
特点：
	- 类加载时，就被初始化
2. 懒汉式单例
![eagersingleton.gif](eagersingleton.gif)
特点：
	- 第一次调用getInstance()方法时实例化，在类加载时并不自行实例化
	- 需要注意线程安全,一般通过**synchronized**解决，一对getInstance()函数直接加线程锁，二可以对getInstance()中实例化对象那一块进行**double-check**，避免并发时产生多个实例对象。
3. IoDH单例
通过静态内部类（不依赖于外部类实例被实例化）实现。
特点：
	- 由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。

--------
* 效果
 优点：
 	- 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它
 	- 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。
 	- 允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。

 缺点: 
 	- 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
 	- 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。